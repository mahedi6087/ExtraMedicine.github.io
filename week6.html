<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Advanced Cryptography Demo</title>
  <style>
    /* Reset & base */
    * {
      box-sizing: border-box;
    }
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      padding: 30px 40px;
      background: linear-gradient(135deg, #0f2027, #203a43, #2c5364);
      color: #e0e6f0;
      transition: background 0.4s, color 0.4s;
      min-height: 100vh;
    }
    body.dark {
      background: linear-gradient(135deg, #121212, #1e1e1e, #272727);
      color: #cfd8dc;
    }

    h1, h2 {
      text-align: center;
      font-weight: 700;
      letter-spacing: 1.5px;
      margin-bottom: 15px;
      text-shadow: 0 0 10px rgba(0, 150, 255, 0.6);
    }

    .section {
      margin-bottom: 40px;
      background: rgba(255,255,255,0.05);
      padding: 25px 30px;
      border-radius: 14px;
      box-shadow: 0 8px 24px rgba(0, 150, 255, 0.15);
      backdrop-filter: blur(10px);
    }

    textarea {
      width: 100%;
      height: 110px;
      border-radius: 10px;
      border: none;
      padding: 15px;
      font-size: 1.1rem;
      font-family: 'Consolas', monospace;
      resize: vertical;
      background-color: rgba(255,255,255,0.15);
      color: #e0e6f0;
      box-shadow: inset 0 0 8px rgba(0, 150, 255, 0.3);
      transition: background-color 0.3s;
    }
    textarea:focus {
      outline: none;
      background-color: rgba(0, 150, 255, 0.2);
      box-shadow: inset 0 0 12px #0096ff;
      color: #fff;
    }

    input[type="file"] {
      margin-top: 15px;
      color: #ddd;
      font-size: 1rem;
      font-weight: 500;
    }

    label {
      font-size: 1rem;
      user-select: none;
      cursor: pointer;
      margin-right: 25px;
      display: inline-flex;
      align-items: center;
      gap: 8px;
      color: #a0b9d6;
      transition: color 0.3s;
    }
    label:hover {
      color: #00aaff;
    }

    input[type="checkbox"] {
      width: 18px;
      height: 18px;
      cursor: pointer;
    }

    button {
      background: linear-gradient(90deg, #00bfff, #1e90ff);
      border: none;
      border-radius: 12px;
      color: white;
      font-weight: 600;
      font-size: 1.05rem;
      padding: 12px 26px;
      margin: 10px 10px 0 0;
      cursor: pointer;
      box-shadow: 0 6px 15px rgba(0, 191, 255, 0.5);
      transition: background 0.25s ease, box-shadow 0.25s ease;
      user-select: none;
    }
    button:hover {
      background: linear-gradient(90deg, #1e90ff, #00bfff);
      box-shadow: 0 8px 24px rgba(0, 191, 255, 0.75);
    }
    button:active {
      box-shadow: 0 3px 8px rgba(0, 191, 255, 0.8);
      transform: scale(0.98);
    }

    .copy-btn {
      float: right;
      font-size: 0.85rem;
      padding: 6px 12px;
      background: #0096ff;
      border-radius: 8px;
      border: none;
      color: #e0e6f0;
      font-weight: 600;
      box-shadow: 0 4px 12px rgba(0, 150, 255, 0.7);
      transition: background 0.3s;
      user-select: none;
    }
    .copy-btn:hover {
      background: #00c0ff;
    }
    body.dark .copy-btn {
      background: #005f99;
      color: #d0e6ff;
    }

    .results {
      white-space: pre-wrap;
      background: rgba(255,255,255,0.1);
      padding: 15px 20px;
      margin-top: 12px;
      border-radius: 12px;
      font-family: 'Consolas', monospace;
      font-size: 1rem;
      box-shadow: inset 0 0 10px rgba(0, 150, 255, 0.3);
      color: #cce7ff;
      user-select: text;
      min-height: 40px;
      position: relative;
      overflow-wrap: break-word;
    }
    body.dark .results {
      background: rgba(0,0,0,0.3);
      box-shadow: inset 0 0 12px #0096ff;
      color: #a3cfff;
    }

    .algorithm {
      margin-top: 30px;
      border-top: 1px solid rgba(255,255,255,0.1);
      padding-top: 20px;
      position: relative;
    }

    .algo-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    /* Description toggle */
    details {
      margin-top: 12px;
      background: rgba(0, 150, 255, 0.1);
      padding: 15px 18px;
      border-radius: 10px;
      box-shadow: inset 0 0 8px rgba(0, 150, 255, 0.3);
      cursor: pointer;
      transition: background 0.3s ease;
      user-select: none;
    }
    details[open] {
      background: rgba(0, 150, 255, 0.25);
    }
    details summary {
      font-weight: 600;
      font-size: 1.05rem;
      color: #cce7ff;
      outline: none;
      list-style: none;
      user-select: none;
      cursor: pointer;
      display: inline-block;
      text-shadow: 0 0 5px #0096ff;
    }
    details summary::-webkit-details-marker {
      display: none;
    }
    details[open] summary::after {
      content: "▲";
      margin-left: 8px;
      font-size: 0.8rem;
      color: #00aaff;
    }
    details summary::after {
      content: "▼";
      margin-left: 8px;
      font-size: 0.8rem;
      color: #00aaff;
    }

    /* Animation containers */
    .animation-container {
      margin-top: 12px;
      font-family: 'Consolas', monospace;
      font-size: 1.15rem;
      min-height: 40px;
      color: #90caf9;
      user-select: none;
      background: rgba(0,0,0,0.15);
      border-radius: 10px;
      padding: 8px 12px;
      box-shadow: inset 0 0 8px rgba(0, 120, 255, 0.5);
      overflow-x: auto;
      white-space: nowrap;
    }
    body.dark .animation-container {
      background: rgba(255,255,255,0.07);
      box-shadow: inset 0 0 10px #007bff;
      color: #bbdefb;
    }

    /* Spinner */
    .spinner {
      display: inline-block;
      width: 16px;
      height: 16px;
      border: 3px solid rgba(0, 150, 255, 0.3);
      border-top-color: #0096ff;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      vertical-align: middle;
      margin-left: 8px;
    }
    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    /* Dark toggle button */
    .toggle-dark {
      position: fixed;
      top: 20px;
      right: 20px;
      background: #00aaff;
      color: white;
      border: none;
      border-radius: 30px;
      width: 50px;
      height: 50px;
      cursor: pointer;
      font-size: 1.4rem;
      box-shadow: 0 6px 14px rgba(0, 170, 255, 0.6);
      transition: background 0.3s ease;
      user-select: none;
    }
    .toggle-dark:hover {
      background: #0077cc;
    }

    /* Tooltip */
    [data-tooltip] {
      position: relative;
      cursor: help;
    }
    [data-tooltip]:hover::after {
      content: attr(data-tooltip);
      position: absolute;
      bottom: 125%;
      left: 50%;
      transform: translateX(-50%);
      background: #0096ffdd;
      color: white;
      padding: 6px 10px;
      border-radius: 6px;
      white-space: nowrap;
      font-size: 0.9rem;
      pointer-events: none;
      opacity: 1;
      transition: opacity 0.3s ease;
      z-index: 1000;
    }
    [data-tooltip]::after {
      opacity: 0;
      pointer-events: none;
    }
  </style>
</head>
<body>

  <button class="toggle-dark" id="darkToggle" aria-label="Toggle dark mode" title="Toggle dark mode">🌙</button>

  <h1>Advanced Cryptography Demo</h1>

  <section class="section">
    <label for="textInput" data-tooltip="Type or paste text to encrypt/decrypt">
      Enter Text:
    </label>
    <textarea id="textInput" placeholder="Enter text here..." spellcheck="false" autocomplete="off"></textarea>
    <br/>
    <input type="file" id="fileInput" accept=".txt" />
  </section>

  <section class="section" id="optionsSection">
    <label for="modeToggle" data-tooltip="Toggle between Encrypt and Decrypt mode">
      <input type="checkbox" id="modeToggle" /> Decrypt Mode
    </label>
    <label for="animateToggle" data-tooltip="Enable/disable animated step-by-step visualization">
      <input type="checkbox" id="animateToggle" checked /> Animate Steps
    </label>
    <button id="processBtn" aria-label="Process encryption or decryption">Process</button>
    <button id="clearBtn" aria-label="Clear all inputs and outputs">Clear</button>
  </section>

  <section class="section" id="resultsSection">
    <h2>Results</h2>
    <div id="resultsContainer">
      <!-- Algorithm results go here -->
    </div>
  </section>

  <script>
    // === Dark mode toggle ===
    const darkToggle = document.getElementById('darkToggle');
    darkToggle.onclick = () => {
      document.body.classList.toggle('dark');
      darkToggle.textContent = document.body.classList.contains('dark') ? '☀️' : '🌙';
    };

    // === Elements ===
    const textInput = document.getElementById('textInput');
    const fileInput = document.getElementById('fileInput');
    const modeToggle = document.getElementById('modeToggle');
    const animateToggle = document.getElementById('animateToggle');
    const processBtn = document.getElementById('processBtn');
    const clearBtn = document.getElementById('clearBtn');
    const resultsContainer = document.getElementById('resultsContainer');

    // === Algorithms and educational descriptions ===
    const algorithms = [
      {
        name: "Caesar Cipher",
        description: `
The Caesar Cipher is one of the simplest and oldest encryption techniques.
It shifts each letter in the plaintext by a fixed number of positions (shift).
For example, with a shift of 3, A becomes D, B becomes E, etc.
This cipher is easy to break but serves as a foundational example.
        `.trim(),
        key: 3,
        encrypt(text) {
          return [...text].map(c => shiftChar(c, this.key)).join('');
        },
        decrypt(text) {
          return [...text].map(c => shiftChar(c, -this.key)).join('');
        },
        async animate(text, encrypting = true) {
          // Animated stepwise shift each character
          const shift = encrypting ? this.key : -this.key;
          let result = '';
          const container = document.createElement('div');
          container.className = 'animation-container';

          for (let i = 0; i < text.length; i++) {
            const orig = text[i];
            const newChar = shiftChar(orig, shift);
            result += newChar;
            container.textContent = result + '▌';
            await delay(180);
          }
          container.textContent = result;
          return container;
        }
      },
      {
        name: "Atbash Cipher",
        description: `
The Atbash Cipher is a substitution cipher that maps each letter to its reverse in the alphabet.
A becomes Z, B becomes Y, C becomes X, and so forth.
It is symmetric: encrypting and decrypting use the same process.
Though simple, it's a clever substitution cipher from ancient times.
        `.trim(),
        encrypt(text) {
          return [...text].map(c => atbashChar(c)).join('');
        },
        decrypt(text) {
          return this.encrypt(text); // symmetric
        },
        async animate(text, encrypting = true) {
          let result = '';
          const container = document.createElement('div');
          container.className = 'animation-container';

          for (let i = 0; i < text.length; i++) {
            const orig = text[i];
            const newChar = atbashChar(orig);
            result += newChar;
            container.textContent = result + '▌';
            await delay(180);
          }
          container.textContent = result;
          return container;
        }
      },
      {
        name: "ROT13 Cipher",
        description: `
ROT13 is a special case of Caesar Cipher with a fixed shift of 13.
Since the alphabet has 26 letters, applying ROT13 twice returns the original text.
Used historically for obscuring spoilers or puzzle answers.
        `.trim(),
        encrypt(text) {
          return [...text].map(c => rot13Char(c)).join('');
        },
        decrypt(text) {
          return this.encrypt(text); // symmetric
        },
        async animate(text, encrypting = true) {
          let result = '';
          const container = document.createElement('div');
          container.className = 'animation-container';

          for (let i = 0; i < text.length; i++) {
            const orig = text[i];
            const newChar = rot13Char(orig);
            result += newChar;
            container.textContent = result + '▌';
            await delay(180);
          }
          container.textContent = result;
          return container;
        }
      }
    ];

    // === Utility char functions ===

    function shiftChar(c, shift) {
      const A = 'A'.charCodeAt(0);
      const Z = 'Z'.charCodeAt(0);
      const a = 'a'.charCodeAt(0);
      const z = 'z'.charCodeAt(0);
      let code = c.charCodeAt(0);

      if (code >= A && code <= Z) {
        let shifted = ((code - A + shift) % 26 + 26) % 26 + A;
        return String.fromCharCode(shifted);
      } else if (code >= a && code <= z) {
        let shifted = ((code - a + shift) % 26 + 26) % 26 + a;
        return String.fromCharCode(shifted);
      } else {
        return c; // non-alpha unchanged
      }
    }

    function atbashChar(c) {
      const A = 'A'.charCodeAt(0);
      const Z = 'Z'.charCodeAt(0);
      const a = 'a'.charCodeAt(0);
      const z = 'z'.charCodeAt(0);
      let code = c.charCodeAt(0);

      if (code >= A && code <= Z) {
        return String.fromCharCode(Z - (code - A));
      } else if (code >= a && code <= z) {
        return String.fromCharCode(z - (code - a));
      } else {
        return c;
      }
    }

    function rot13Char(c) {
      return shiftChar(c, 13);
    }

    function delay(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }

    // === Main processing function ===
    async function processText() {
      const input = textInput.value.trim();
      if (!input) {
        alert("Please enter some text first.");
        return;
      }

      const encrypting = !modeToggle.checked;
      const animateSteps = animateToggle.checked;

      // Clear previous results
      resultsContainer.innerHTML = '';

      for (const algo of algorithms) {
        const container = document.createElement('div');
        container.className = 'algorithm';

        // Header with algorithm name & mode
        const header = document.createElement('div');
        header.className = 'algo-header';
        header.innerHTML = `
          <h3>${algo.name}</h3>
          <button class="copy-btn" aria-label="Copy ${algo.name} result">Copy</button>
        `;

        container.appendChild(header);

        // Animated result or instant result
        let animationDiv;
        if (animateSteps && algo.animate) {
          // Show spinner while animating
          const spinner = document.createElement('span');
          spinner.className = 'spinner';
          header.appendChild(spinner);

          animationDiv = await algo.animate(input, encrypting);
          spinner.remove();
        } else {
          // Just show plain result
          const outputText = encrypting ? algo.encrypt(input) : algo.decrypt(input);
          animationDiv = document.createElement('div');
          animationDiv.className = 'results';
          animationDiv.textContent = outputText;
        }
        container.appendChild(animationDiv);

        // Description (collapsible)
        const desc = document.createElement('details');
        desc.innerHTML = `<summary>About ${algo.name}</summary><p style="white-space: pre-wrap; margin-top: 10px; line-height: 1.4;">${algo.description}</p>`;
        container.appendChild(desc);

        resultsContainer.appendChild(container);

        // Copy button functionality
        const copyBtn = header.querySelector('.copy-btn');
        copyBtn.onclick = () => {
          // copy from animationDiv content
          let textToCopy;
          if (animationDiv.classList.contains('animation-container') || animationDiv.classList.contains('results')) {
            textToCopy = animationDiv.textContent;
          } else {
            textToCopy = animationDiv.innerText || animationDiv.textContent;
          }
          navigator.clipboard.writeText(textToCopy.trim()).then(() => {
            copyBtn.textContent = 'Copied!';
            setTimeout(() => copyBtn.textContent = 'Copy', 1500);
          }).catch(() => alert('Copy failed. Try manually.'));
        };
      }
    }

    // === File input to load text ===
    fileInput.addEventListener('change', e => {
      const file = e.target.files[0];
      if (file && file.type === "text/plain") {
        const reader = new FileReader();
        reader.onload = (ev) => {
          textInput.value = ev.target.result;
        };
        reader.readAsText(file);
      } else {
        alert("Please select a valid .txt file.");
      }
    });

    // === Button events ===
    processBtn.onclick = processText;

    clearBtn.onclick = () => {
      textInput.value = '';
      fileInput.value = '';
      resultsContainer.innerHTML = '';
    };

    // Optional: process live on input (can be disabled if needed)
    // textInput.addEventListener('input', () => {
    //   if (!modeToggle.checked) processText();
    // });

  </script>

</body>
</html>
